{"version":3,"sources":["index.js"],"names":["Container","useEffect","container","camera","scene","renderer","controller","raycaster","mouse","hitTestSource","hitTestSourceRequested","onWindowResize","aspect","window","innerWidth","innerHeight","updateProjectionMatrix","setSize","render","timestamp","frame","xr","getReferenceSpace","session","getSession","requestReferenceSpace","then","referenceSpace","requestHitTestSource","space","source","addEventListener","hitTestResults","getHitTestResults","length","document","querySelector","THREE","silhouette","load","light","position","set","add","antialias","alpha","setPixelRatio","devicePixelRatio","enabled","appendChild","domElement","console","log","body","event","x","clientX","y","clientY","planeMesh","side","color","rotation","Math","PI","ARButton","createButton","requiredFeatures","geometry","material","flatShading","map","silhouetteMesh","visible","getController","setFromCamera","intPoint","intersectObjects","children","point","z","init","setAnimationLoop","className","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.3f5d3817.chunk.js","sourcesContent":["import React, { useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport * as THREE from           'three';\nimport { RGBELoader } from       'three/examples/jsm/loaders/RGBELoader.js';\nimport { ARButton } from         'three/examples/jsm/webxr/ARButton.js';\nimport { XREstimatedLight } from 'three/examples/jsm/webxr/XREstimatedLight';\n\nfunction Container() {\n\n    // Three.js functionality is all inside useEffect on comp mount\n    useEffect(() => {\n\n        // define variables\n        let container;\n        let camera, scene, renderer;\n        let controller;\n        let reticle;\n        let raycaster;\n        let mouse;\n\n        // set hit test\n        let hitTestSource = null;\n        let hitTestSourceRequested = false;\n\n        init();\n        animate();\n\n        function init() {\n            // get container for the canvas\n            container = document.querySelector( '.scene' );\n\n            // set Scene\n            scene = new THREE.Scene();\n\n            // load Textures\n            const textureLoader = new THREE.TextureLoader()\n            const silhouette = textureLoader.load('./textures/silhouette.png')\n\n            // set Camera\n            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n            // set Light and add to the Scene\n            const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );\n            light.position.set( 0.5, 1, 0.25 );\n            scene.add( light );\n\n            // set renderer \n            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n            renderer.setPixelRatio( window.devicePixelRatio );\n            renderer.setSize( window.innerWidth, window.innerHeight );\n            // enable XR and use container\n            renderer.xr.enabled = true;\n            container.appendChild( renderer.domElement );\n\n\n\n            // cast a ray\n            raycaster = new THREE.Raycaster()\n            console.log('camera.position', camera.position)\n            const rayOrigin = camera.position\n            // const rayDirection = new THREE.Vector3(0, 0, -10)\n            // rayDirection.normalize()\n            // raycaster.set(rayOrigin, rayDirection)\n\n            mouse = new THREE.Vector2()\n\n            const onTouch = ( event ) => {\n                // calculate mouse position in normalized device coordinates\n\t            // (-1 to +1) for both components\n\n\t            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n                console.log(mouse.x, mouse.y)\n            }\n\n            document.body.addEventListener('click', onTouch)\n\n\n\n            // TEST ground planeMesh\n            const planeMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(10, 10, 1, 1), new THREE.MeshStandardMaterial({\n                side: THREE.DoubleSide,\n                color: 0x808080,\n            }))\n            planeMesh.rotation.x = Math.PI / 2\n            planeMesh.position.set(0, -1, -2)\n            scene.add(planeMesh)\n\n            // add AR button and require hit-test\n            document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );\n\n            // cylinder\n            const geometry = new THREE.PlaneBufferGeometry(3, 8.5, 1)\n            const material = new THREE.MeshPhongMaterial( {\n                flatShading: true,\n                side: THREE.DoubleSide,\n                map: silhouette,\n            } );\n            const silhouetteMesh = new THREE.Mesh( geometry, material );\n            scene.add( silhouetteMesh );\n            silhouetteMesh.visible = false\n\n// on user select add cylinder to the reticle position\n            function onSelect() {\n                raycaster.setFromCamera( mouse, camera )\n                const intersects = raycaster.intersectObjects( scene.children, false );\n                const intPoint = intersects[0].point\n                console.log(intPoint)\n                if (!silhouetteMesh.visible) {\n                    silhouetteMesh.position.set(intPoint.x, intPoint.y + 4.25, intPoint.z)\n                    silhouetteMesh.visible = true\n                }\n            }\n\n            // get Controller (touch screen)\n            controller = renderer.xr.getController( 0 );\n            controller.addEventListener( 'select', onSelect );\n            scene.add( controller );\n\n            // create Reticle\n            // reticle = new THREE.Mesh(\n            //     new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),\n            //     new THREE.MeshBasicMaterial()\n            // );\n            // reticle.matrixAutoUpdate = false;\n            // reticle.visible = false;\n            // scene.add( reticle );\n            \n            // set resize handler\n            window.addEventListener( 'resize', onWindowResize );\n        }\n\n        // resize handler\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n\n            renderer.setSize( window.innerWidth, window.innerHeight );\n        }\n\n        // Animations\n        function animate() {\n            renderer.setAnimationLoop( render );\n        }\n\n        // Render\n        function render( timestamp, frame ) {\n            if ( frame ) {\n                // get reference space of device\n                const referenceSpace = renderer.xr.getReferenceSpace();\n\n                // get session object\n                const session = renderer.xr.getSession();\n \n                if ( hitTestSourceRequested === false ) {\n                    // get the Viewer ref space\n                    session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {\n                        // then use it to get hitTestSource\n                        session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {\n                            hitTestSource = source;\n                        } );\n\n                    } );\n\n                    // on Session end remove hit test\n                    session.addEventListener( 'end', function () {\n                        hitTestSourceRequested = false;\n                        hitTestSource = null;\n                    } );\n\n                    hitTestSourceRequested = true;\n                }\n\n                if ( hitTestSource ) {\n\n                    // get hit test results\n                    const hitTestResults = frame.getHitTestResults( hitTestSource );\n\n                    if ( hitTestResults.length ) {\n                        // get first result\n                        const hit = hitTestResults[ 0 ];\n                        // show and place reticle\n                        // reticle.visible = true;\n                        // reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );\n\n                    } else {\n                        // reticle.visible = false;\n                    }\n                }\n            }\n            renderer.render( scene, camera );\n        }\n\n    }, [])\n\n    return (\n        <>\n            <div className=\"scene\" />\n        </>\n    )\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<Container />, rootElement);"],"sourceRoot":""}