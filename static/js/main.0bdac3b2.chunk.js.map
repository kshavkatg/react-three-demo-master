{"version":3,"sources":["libs/ControllerGestures.js","index.js"],"names":["ControllerGestures","renderer","undefined","console","error","clock","THREE","controller1","xr","getController","userData","gestures","index","selectPressed","addEventListener","onSelectStart","onSelectEnd","controller2","doubleClickLimit","pressMinimum","right","up","type","touchCount","self","data","this","startPosition","startTime","getElapsedTime","indexOf","taps","log","endTime","startToEnd","direction","position","y","dispatchEvent","matrixWorld","data1","data2","currentTime","clone","touch","multiTouch","startDistance","distanceTo","delta","Math","abs","scale","initialise","v1","sub","normalize","v2","theta","angleTo","startVector","dist","velocity","v","x","z","currentDistance","cross","dot","result","Container","useEffect","container","camera","scene","controller","raycaster","mouse","hitTestSource","hitTestSourceRequested","onWindowResize","aspect","window","innerWidth","innerHeight","updateProjectionMatrix","setSize","render","timestamp","frame","getReferenceSpace","session","getSession","requestReferenceSpace","then","referenceSpace","requestHitTestSource","space","source","hitTestResults","getHitTestResults","length","document","querySelector","silhouette","load","light","set","add","antialias","alpha","setPixelRatio","devicePixelRatio","enabled","appendChild","domElement","onTouch","event","clientX","clientY","body","planeMesh","side","transparent","opacity","rotation","PI","ARButton","createButton","requiredFeatures","geometry","material","map","silhouetteMesh","visible","setFromCamera","intPoint","intersectObjects","children","point","init","setAnimationLoop","className","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.0bdac3b2.chunk.js","sourcesContent":["import * as THREE from 'three';\n\nclass ControllerGestures extends THREE.EventDispatcher{\n    constructor( renderer ){\n        super();\n        \n        if (renderer === undefined){\n            console.error('ControllerGestures must be passed a renderer');\n            return;\n        }\n        \n        const clock = new THREE.Clock();\n        \n        this.controller1 = renderer.xr.getController(0);\n        this.controller1.userData.gestures = { index: 0 };\n        this.controller1.userData.selectPressed = false;\n        this.controller1.addEventListener( 'selectstart', onSelectStart );\n        this.controller1.addEventListener( 'selectend', onSelectEnd );\n        \n        this.controller2 = renderer.xr.getController(1);\n        this.controller2.userData.gestures = { index: 1 };\n        this.controller2.userData.selectPressed = false;\n        this.controller2.addEventListener( 'selectstart', onSelectStart );\n        this.controller2.addEventListener( 'selectend', onSelectEnd );\n        \n        this.doubleClickLimit = 0.2;\n        this.pressMinimum = 0.4;\n        this.right = new THREE.Vector3(1,0,0);\n        this.up = new THREE.Vector3(0,1,0);\n        \n        this.type = 'unknown';\n        this.touchCount = 0;\n        \n        this.clock = clock;\n        \n        const self = this;\n        \n        function onSelectStart( ){\n            const data = this.userData.gestures;\n            \n            data.startPosition = undefined;\n            data.startTime = clock.getElapsedTime();\n            \n            if ( self.type.indexOf('tap') == -1) data.taps = 0;\n            \n            self.type = 'unknown';\n            this.userData.selectPressed = true;\n            \n            self.touchCount++;\n            \n            console.log( `onSelectStart touchCount: ${ self.touchCount }` );\n        }\n        \n        function onSelectEnd( ){\n            const data = this.userData.gestures;\n            \n            data.endTime = clock.getElapsedTime();\n            const startToEnd = data.endTime - data.startTime;\n            \n            //console.log(`ControllerGestures.onSelectEnd: startToEnd:${startToEnd.toFixed(2)} taps:${data.taps}`);\n            \n            if (self.type === 'swipe'){\n                const direction = ( self.controller1.position.y < data.startPosition.y) ? \"DOWN\" : \"UP\";\n                self.dispatchEvent( { type:'swipe', direction } );\n                self.type = 'unknown';\n            }else if (self.type !== \"pinch\" && self.type !== \"rotate\" && self.type !== 'pan'){\n                if ( startToEnd < self.doubleClickLimit ){\n                    self.type = \"tap\";\n                    data.taps++;\n                }else if ( startToEnd > self.pressMinimum ){\n                    self.dispatchEvent( { type: 'press', position: self.controller1.position, matrixWorld: self.controller1.matrixWorld }   );\n                    self.type = 'unknown';\n                }\n            }else{\n                self.type = 'unknown';\n            }\n            \n            this.userData.selectPressed = false;\n            data.startPosition = undefined;\n            \n            self.touchCount--;\n        }\n    }\n    \n    get multiTouch(){\n        let result;\n        if ( this.controller1 === undefined || this.controller2 === undefined ){   \n            result = false;\n        }else{\n            result = this.controller1.userData.selectPressed && this.controller2.userData.selectPressed;\n        }\n        const self = this;\n        console.log( `ControllerGestures multiTouch: ${result} touchCount:${self.touchCount}`);\n        return result;\n    }\n    \n    get touch(){\n        let result;\n        if ( this.controller1 === undefined || this.controller2 === undefined ){   \n            result = false;\n        }else{\n            result = this.controller1.userData.selectPressed || this.controller2.userData.selectPressed;\n        }\n        //console.log( `ControllerGestures touch: ${result}`);\n        return result;\n    }\n    \n    get debugMsg(){\n        return this.type;\n    }\n    \n    update(){\n        const data1 = this.controller1.userData.gestures;\n        const data2 = this.controller2.userData.gestures;\n        const currentTime = this.clock.getElapsedTime();\n        \n        let elapsedTime;\n        \n        if (this.controller1.userData.selectPressed && data1.startPosition === undefined){\n            elapsedTime = currentTime - data1.startTime;\n            if (elapsedTime > 0.05 ) data1.startPosition = this.controller1.position.clone();\n        }\n        \n        if (this.controller2.userData.selectPressed && data2.startPosition === undefined){\n            elapsedTime = currentTime - data2.startTime;\n            if (elapsedTime > 0.05 ) data2.startPosition = this.controller2.position.clone();\n        }\n        \n        if (!this.controller1.userData.selectPressed && this.type === 'tap' ){\n            //Only dispatch event after double click limit is passed\n            elapsedTime = this.clock.getElapsedTime() - data1.endTime;\n            if (elapsedTime > this.doubleClickLimit){\n                //console.log( `ControllerGestures.update dispatchEvent taps:${data1.taps}` );\n                switch( data1.taps ){\n                    case 1:\n                        this.dispatchEvent( { type: 'tap', position: this.controller1.position, matrixWorld: this.controller1.matrixWorld } );\n                        break;\n                    case 2:\n                        this.dispatchEvent( { type: 'doubletap', position: this.controller1.position, matrixWorld: this.controller1.matrixWorld } );\n                        break;\n                    case 3:\n                        this.dispatchEvent( { type: 'tripletap', position: this.controller1.position, matrixWorld: this.controller1.matrixWorld } );\n                        break;\n                    case 4:\n                        this.dispatchEvent( { type: 'quadtap', position: this.controller1.position, matrixWorld: this.controller1.matrixWorld }  );\n                        break;\n                }\n                this.type = \"unknown\";\n                data1.taps = 0;\n            }\n        }\n        \n        if (this.type === 'unknown' && this.touch){\n            if (data1.startPosition !== undefined){\n                if (this.multiTouch){\n                    if (data2.startPosition !== undefined){\n                        //startPosition is undefined for 1/20 sec\n                        //test for pinch or rotate\n                        const startDistance = data1.startPosition.distanceTo( data2.startPosition );\n                        const currentDistance = this.controller1.position.distanceTo( this.controller2.position );\n                        const delta = currentDistance - startDistance;\n                        if ( Math.abs(delta) > 0.01 ){\n                            this.type = 'pinch';\n                            this.startDistance = this.controller1.position.distanceTo( this.controller2.position );\n                            this.dispatchEvent( { type: 'pinch', delta: 0, scale: 1, initialise: true } );\n                        }else{\n                            const v1 = data2.startPosition.clone().sub( data1.startPosition ).normalize();\n                            const v2 = this.controller2.position.clone().sub( this.controller1.position ).normalize();\n                            const theta = v1.angleTo( v2 );\n                            if (Math.abs(theta) > 0.2){\n                                this.type = 'rotate';\n                                this.startVector = v2.clone();\n                                this.dispatchEvent( { type: 'rotate', theta: 0, initialise: true } );\n                            }\n                        }\n                    }\n                }else{\n                    //test for swipe or pan\n                    let dist = data1.startPosition.distanceTo( this.controller1.position );\n                    elapsedTime = this.clock.getElapsedTime() - data1.startTime;\n                    const velocity = dist/elapsedTime;\n                    //console.log(`dist:${dist.toFixed(3)} velocity:${velocity.toFixed(3)}`);\n                    if ( dist > 0.01 && velocity > 0.1 ){\n                        const v = this.controller1.position.clone().sub( data1.startPosition );\n                        let maxY = (Math.abs(v.y) > Math.abs(v.x)) && (Math.abs(v.y) > Math.abs(v.z));\n                        if ( maxY )this.type = \"swipe\";\n                    }else if (dist > 0.006 && velocity < 0.03){\n                        this.type = \"pan\";\n                        this.startPosition = this.controller1.position.clone();\n                        this.dispatchEvent( { type: 'pan', delta: new THREE.Vector3(), initialise: true } );\n                    }\n                }\n            }\n        }else if (this.type === 'pinch'){\n            const currentDistance = this.controller1.position.distanceTo( this.controller2.position );\n            const delta = currentDistance - this.startDistance;\n            const scale = currentDistance/this.startDistance;\n            this.dispatchEvent( { type: 'pinch', delta, scale });\n        }else if (this.type === 'rotate'){\n            const v = this.controller2.position.clone().sub( this.controller1.position ).normalize();\n            let theta = this.startVector.angleTo( v );\n            const cross = this.startVector.clone().cross( v );\n            if (this.up.dot(cross) > 0) theta = -theta;\n            this.dispatchEvent( { type: 'rotate', theta } );\n        }else if (this.type === 'pan'){\n            const delta = this.controller1.position.clone().sub( this.startPosition );\n            this.dispatchEvent( { type: 'pan', delta } );\n        }\n    }\n}\n\nexport { ControllerGestures };","import React, { useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport * as THREE from           'three';\nimport { RGBELoader } from       'three/examples/jsm/loaders/RGBELoader.js';\nimport { ARButton } from         'three/examples/jsm/webxr/ARButton.js';\nimport { ControllerGestures } from './libs/ControllerGestures'\n\nfunction Container() {\n\n    // Three.js functionality is all inside useEffect on comp mount\n    useEffect(() => {\n\n        // define variables\n        let container;\n        let camera, scene, renderer;\n        let controller;\n        let reticle;\n        let raycaster;\n        let mouse;\n\n        // set hit test\n        let hitTestSource = null;\n        let hitTestSourceRequested = false;\n\n        init();\n        animate();\n\n        function init() {\n            // get container for the canvas\n            container = document.querySelector( '.scene' );\n\n            // set Scene\n            scene = new THREE.Scene();\n\n            // load Textures\n            const textureLoader = new THREE.TextureLoader()\n            const silhouette = textureLoader.load('./textures/silhouette.png')\n\n            // set Camera\n            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n            // set Light and add to the Scene\n            const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );\n            light.position.set( 0.5, 1, 0.25 );\n            scene.add( light );\n\n            // set renderer \n            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n            renderer.setPixelRatio( window.devicePixelRatio );\n            renderer.setSize( window.innerWidth, window.innerHeight );\n            // enable XR and use container\n            renderer.xr.enabled = true;\n            container.appendChild( renderer.domElement );\n\n            const gestures = new ControllerGestures(renderer)\n\n            // cast a ray\n            raycaster = new THREE.Raycaster()\n            console.log('camera.position', camera.position)\n            const rayOrigin = camera.position\n            // const rayDirection = new THREE.Vector3(0, 0, -10)\n            // rayDirection.normalize()\n            // raycaster.set(rayOrigin, rayDirection)\n\n            mouse = new THREE.Vector2()\n\n            const onTouch = ( event ) => {\n                // calculate mouse position in normalized device coordinates\n\t            // (-1 to +1) for both components\n                console.log('tap')\n\t            mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;\n\t            mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;\n                console.log(mouse.x, mouse.y)\n            }\n\n            document.body.addEventListener('click', onTouch)\n            gestures.addEventListener('tap', onTouch)\n\n            // TEST ground planeMesh\n            const planeMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry(100, 100, 1, 1), new THREE.MeshStandardMaterial({\n                side: THREE.DoubleSide,\n                transparent: true,\n                opacity: 0,\n            }))\n            planeMesh.rotation.x = Math.PI / 2\n            planeMesh.position.set(0, -1.4, -2)\n            scene.add(planeMesh)\n\n            // add AR button and require hit-test\n            document.body.appendChild( ARButton.createButton( renderer, { requiredFeatures: [ 'hit-test' ] } ) );\n\n            // cylinder\n            const geometry = new THREE.PlaneBufferGeometry(0.7, 2, 1)\n            const material = new THREE.MeshStandardMaterial( {\n                transparent: true,\n                side: THREE.DoubleSide,\n                map: silhouette,\n            } );\n            const silhouetteMesh = new THREE.Mesh( geometry, material );\n            scene.add( silhouetteMesh );\n            silhouetteMesh.visible = false\n\n            // on user select add cylinder to the reticle position\n            function onSelect() {\n                raycaster.setFromCamera( mouse, camera )\n                const intersects = raycaster.intersectObjects( scene.children, false );\n                const intPoint = intersects[0].point\n                console.log(intPoint)\n                if (!silhouetteMesh.visible) {\n                    silhouetteMesh.position.set(intPoint.x, intPoint.y + 1, intPoint.z)\n                    silhouetteMesh.visible = true\n                } else if (silhouetteMesh.visible) {\n                    silhouetteMesh.position.set(intPoint.x, intPoint.y + 1, intPoint.z)\n                }\n            }\n\n            // get Controller (touch screen)\n            controller = renderer.xr.getController( 0 );\n            controller.addEventListener( 'select', onSelect );\n            scene.add( controller );\n\n            // create Reticle\n            // reticle = new THREE.Mesh(\n            //     new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),\n            //     new THREE.MeshBasicMaterial()\n            // );\n            // reticle.matrixAutoUpdate = false;\n            // reticle.visible = false;\n            // scene.add( reticle );\n            \n            // set resize handler\n            window.addEventListener( 'resize', onWindowResize );\n        }\n\n        // resize handler\n        function onWindowResize() {\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n\n            renderer.setSize( window.innerWidth, window.innerHeight );\n        }\n\n        // Animations\n        function animate() {\n            renderer.setAnimationLoop( render );\n        }\n\n        // Render\n        function render( timestamp, frame ) {\n            if ( frame ) {\n                // get reference space of device\n                const referenceSpace = renderer.xr.getReferenceSpace();\n\n                // get session object\n                const session = renderer.xr.getSession();\n \n                if ( hitTestSourceRequested === false ) {\n                    // get the Viewer ref space\n                    session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {\n                        // then use it to get hitTestSource\n                        session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {\n                            hitTestSource = source;\n                        } );\n\n                    } );\n\n                    // on Session end remove hit test\n                    session.addEventListener( 'end', function () {\n                        hitTestSourceRequested = false;\n                        hitTestSource = null;\n                    } );\n\n                    hitTestSourceRequested = true;\n                }\n\n                if ( hitTestSource ) {\n\n                    // get hit test results\n                    const hitTestResults = frame.getHitTestResults( hitTestSource );\n\n                    if ( hitTestResults.length ) {\n                        // get first result\n                        const hit = hitTestResults[ 0 ];\n                        // show and place reticle\n                        // reticle.visible = true;\n                        // reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );\n\n                    } else {\n                        // reticle.visible = false;\n                    }\n                }\n            }\n            renderer.render( scene, camera );\n        }\n\n    }, [])\n\n    return (\n        <>\n            <div className=\"scene\" />\n        </>\n    )\n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<Container />, rootElement);"],"sourceRoot":""}