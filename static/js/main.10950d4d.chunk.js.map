{"version":3,"sources":["index.js"],"names":["Container","useEffect","camera","scene","renderer","controller","onWindowResize","aspect","window","innerWidth","innerHeight","updateProjectionMatrix","setSize","render","container","document","createElement","body","appendChild","THREE","defaultLight","add","antialias","alpha","setPixelRatio","devicePixelRatio","outputEncoding","physicallyCorrectLights","xr","enabled","domElement","RGBELoader","setDataType","setPath","load","texture","envMap","mapping","traverse","object","isMesh","material","ARButton","createButton","optionalFeatures","ballGeometry","ballGroup","position","z","i","j","ballMaterial","color","reflectivity","ballMesh","set","rows","cols","getController","addEventListener","applyMatrix4","matrixWorld","quaternion","setFromRotationMatrix","init","setAnimationLoop","console","log","XREstimatedLight","rootElement","getElementById","ReactDOM"],"mappings":"+JAAA,4EASA,SAASA,IAsKL,OArKAC,qBAAU,WACN,IAAIC,EAAQC,EAAOC,EACfC,EA6HJ,SAASC,IAELJ,EAAOK,OAASC,OAAOC,WAAaD,OAAOE,YAC3CR,EAAOS,yBAEPP,EAASQ,QAASJ,OAAOC,WAAYD,OAAOE,aAYhD,SAASG,IAELT,EAASS,OAAQV,EAAOD,IA1I5B,WAEI,IAAMY,EAAYC,SAASC,cAAe,OAC1CD,SAASE,KAAKC,YAAaJ,GAE3BX,EAAQ,IAAIgB,IAEZjB,EAAS,IAAIiB,IAAyB,GAAIX,OAAOC,WAAaD,OAAOE,YAAa,IAAM,IAExF,IAAMU,EAAe,IAAID,IAAoB,UAC7ChB,EAAMkB,IAAKD,IAIXhB,EAAW,IAAIe,IAAqB,CAAEG,WAAW,EAAMC,OAAO,KACrDC,cAAehB,OAAOiB,kBAC/BrB,EAASQ,QAASJ,OAAOC,WAAYD,OAAOE,aAC5CN,EAASsB,eAAiBP,IAC1Bf,EAASuB,yBAA0B,EACnCvB,EAASwB,GAAGC,SAAU,EACtBf,EAAUI,YAAad,EAAS0B,aAmChC,IAAIC,KACCC,YAAab,KACbc,QAAS,6BACTC,KAAM,0BAA0B,SAAWC,GAoFpD,IAA4BC,EAlFhBD,EAAQE,QAAUlB,IAkFFiB,EAhFKD,EAkF7BhC,EAAMmC,UAAU,SAAWC,GAElBA,EAAOC,SAASD,EAAOE,SAASL,OAASA,SA3ElDrB,SAASE,KAAKC,YAAawB,IAASC,aAAcvC,EAAU,CAAEwC,iBAAkB,CAAE,uBAIlF,IAAMC,EAAe,IAAI1B,IAA4B,KAAO,GAAI,IAC1D2B,EAAY,IAAI3B,IACtB2B,EAAUC,SAASC,GAAM,EAKzB,IAHA,IAGUC,EAAI,EAAGA,EAHJ,EAGcA,IAEvB,IAAM,IAAIC,EAAI,EAAGA,EAJR,EAIkBA,IAAO,CAE9B,IAAMC,EAAe,IAAIhC,IAAyB,CAC9CiC,MAAO,SACPC,aAAcH,EARb,IAUCI,EAAW,IAAInC,IAAY0B,EAAcM,GAC/CG,EAASP,SAASQ,IAAgC,IAAzBN,EAAI,GAAMO,IAA+C,IAAzBN,EAAI,GAAMO,GAAoB,GACvFX,EAAUzB,IAAKiC,GAMvBnD,EAAMkB,IAAKyB,IAWXzC,EAAaD,EAASwB,GAAG8B,cAAe,IAC7BC,iBAAkB,UAR7B,WAEIb,EAAUC,SAASQ,IAAK,EAAG,GAAK,GAAIK,aAAcvD,EAAWwD,aAC7Df,EAAUgB,WAAWC,sBAAuB1D,EAAWwD,gBAM3D1D,EAAMkB,IAAKhB,GAIXG,OAAOmD,iBAAkB,SAAUrD,GAtHvC0D,GAuII5D,EAAS6D,iBAAkBpD,KAqBhC,IAKC,oCACI,+BA1KZqD,QAAQC,IAAIC,KAgLZ,IAAMC,EAActD,SAASuD,eAAe,QAC5CC,IAAS1D,OAAO,kBAACb,EAAD,MAAeqE,K","file":"static/js/main.10950d4d.chunk.js","sourcesContent":["import React, { useEffect } from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport * as THREE from           'three';\nimport { RGBELoader } from       'three/examples/jsm/loaders/RGBELoader.js';\nimport { ARButton } from         'three/examples/jsm/webxr/ARButton.js';\nimport { XREstimatedLight } from 'three/examples/jsm/webxr/XREstimatedLight';\nconsole.log(XREstimatedLight)\n\nfunction Container() {\n    useEffect(() => {\n        let camera, scene, renderer;\n        let controller;\n        let defaultEnvironment;\n\n        init();\n        animate();\n\n        function init() {\n\n            const container = document.createElement( 'div' );\n            document.body.appendChild( container );\n\n            scene = new THREE.Scene();\n\n            camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );\n\n            const defaultLight = new THREE.AmbientLight( 0xffffff );\n            scene.add( defaultLight );\n\n            //\n\n            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );\n            renderer.setPixelRatio( window.devicePixelRatio );\n            renderer.setSize( window.innerWidth, window.innerHeight );\n            renderer.outputEncoding = THREE.sRGBEncoding;\n            renderer.physicallyCorrectLights = true;\n            renderer.xr.enabled = true;\n            container.appendChild( renderer.domElement );\n\n            // Don't add the XREstimatedLight to the scene initially.\n            // It doesn't have any estimated lighting values until an AR session starts.\n\n            //const xrLight = new XREstimatedLight( renderer );\n\n            // xrLight.addEventListener( 'estimationstart', () => {\n\n            //     // Swap the default light out for the estimated one one we start getting some estimated values.\n            //     scene.add( xrLight );\n            //     scene.remove( defaultLight );\n\n            //     // The estimated lighting also provides an environment cubemap, which we can apply here.\n            //     if ( xrLight.environment ) {\n\n            //         updateEnvironment( xrLight.environment );\n\n            //     }\n\n            // } );\n\n            // xrLight.addEventListener( 'estimationend', () => {\n\n            //     // Swap the lights back when we stop receiving estimated values.\n            //     scene.add( defaultLight );\n            //     scene.remove( xrLight );\n\n            //     // Revert back to the default environment.\n            //     updateEnvironment( defaultEnvironment );\n\n            // } );\n\n            //\n\n            new RGBELoader()\n                .setDataType( THREE.UnsignedByteType )\n                .setPath( 'textures/equirectangular/' )\n                .load( 'royal_esplanade_1k.hdr', function ( texture ) {\n\n                    texture.mapping = THREE.EquirectangularReflectionMapping;\n\n                    defaultEnvironment = texture;\n\n                    updateEnvironment( defaultEnvironment );\n\n                } );\n\n            //\n\n            // In order for lighting estimation to work, 'light-estimation' must be included as either an optional or required feature.\n            document.body.appendChild( ARButton.createButton( renderer, { optionalFeatures: [ 'light-estimation' ] } ) );\n\n            //\n\n            const ballGeometry = new THREE.SphereBufferGeometry( 0.175, 32, 32 );\n            const ballGroup = new THREE.Group();\n            ballGroup.position.z = - 2;\n\n            const rows = 1;\n            const cols = 4;\n\n            for ( let i = 0; i < rows; i ++ ) {\n\n                for ( let j = 0; j < cols; j ++ ) {\n\n                    const ballMaterial = new THREE.MeshPhongMaterial( {\n                        color: 0xdddddd,\n                        reflectivity: j / cols\n                    } );\n                    const ballMesh = new THREE.Mesh( ballGeometry, ballMaterial );\n                    ballMesh.position.set( ( i + 0.5 - rows * 0.5 ) * 0.4, ( j + 0.5 - cols * 0.5 ) * 0.4, 0 );\n                    ballGroup.add( ballMesh );\n\n                }\n\n            }\n\n            scene.add( ballGroup );\n\n            //\n\n            function onSelect() {\n\n                ballGroup.position.set( 0, 0, - 2 ).applyMatrix4( controller.matrixWorld );\n                ballGroup.quaternion.setFromRotationMatrix( controller.matrixWorld );\n\n            }\n\n            controller = renderer.xr.getController( 0 );\n            controller.addEventListener( 'select', onSelect );\n            scene.add( controller );\n\n            //\n\n            window.addEventListener( 'resize', onWindowResize );\n\n        }\n\n        function onWindowResize() {\n\n            camera.aspect = window.innerWidth / window.innerHeight;\n            camera.updateProjectionMatrix();\n\n            renderer.setSize( window.innerWidth, window.innerHeight );\n\n        }\n\n        //\n\n        function animate() {\n\n            renderer.setAnimationLoop( render );\n\n        }\n\n        function render() {\n\n            renderer.render( scene, camera );\n\n        }\n\n        function updateEnvironment( envMap ) {\n\n            scene.traverse( function ( object ) {\n\n                if ( object.isMesh ) object.material.envMap = envMap;\n\n\n            } );\n\n        }\n\n    }, [])\n\n\n\n    return (\n        <>\n            <div />\n        </>\n    )\n    \n}\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<Container />, rootElement);"],"sourceRoot":""}